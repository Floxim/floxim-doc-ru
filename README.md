# Русская дока про Floxim

1. Произношение навания по-русски

Флóксим - ударение на первый слог. Слово мужского рода. Правильно "я возился с Флóксимом". Неправильно: "возилися с Флóксимой", "возился с Флокси́мом" и т.д.

2. Устройство репозиториев

https://github.com/Floxim/floxim-demosite - демо-сайт, подключающий все нужно как git-субмодули. Через некоторое время должен превратиться в Composer-проект.

https://github.com/Floxim/floxim - ядро системы
https://github.com/Floxim/floxim-cache - кэшер

Эти два репозитория попадают в /vendor/floxim/

https://github.com/Floxim/module-smth - модули, попадают в /module/Floxim/Smth 
https://github.com/Floxim/module-main - "главный модуль", объявляющий базовые контроллеры, логику работы контентных типов данных (т.е. объектов, составляющий контент сайта) и т.д. 

Модули и темы можно цеплять Композером, указав тип и подцепив плагин-установщик: https://github.com/Floxim/composer

Еще есть приватные репозитории под моим аккаунтом, там лежит первый набросок сааса.

3. Процесс обработки запроса страницы

 - все запросы приходят на /index.php
 - он подключает /boot.php, где происходит подключение автолодера и загрузка конфига из /config.php
 - для всех модулей пытаемся дернуть метод init() - там можно навешать обработчики событий, зарегистрировать кастомные роутеры и т.д.
 - далее в index.php запрос пропускается через цепочку роутеров, пока какой-нибудь не вернет результат
 - результат выводится на экран.
  
 4. Роутеры
 
Из коробки сейчас есть такие роутеры:
 - Admin - обрабатывает запросы на /floxim/, возвращает JSON для отрисовки админский форм и контролов
 - Infoblock - обрабатывает запросы на /~ib/, используется для перерисовки блоков при редактировании / настройке
 - Ajax - обрабатывает запросы на /~ajax/, позволяет получать результат работы отдельного контроллера / инфоблока, отличается от Infoblock-роутера тем, что не умеет перерисовывать блок с переопределенными параметрами, соответственно может использоваться для обычных пользователей
 - Front - основной роутер, показывающий страницы сайта
 - Error - последний в цепочке, показывает страницу /404/, если ничего не нашлось.

5. Роутер Front
 
Front-роутер работает следующим образом:
 - по URL получает путь к текущей странице
 - для этого у всех зарегистрированных роутеров опрашивается метод getPath($url, $site_id), по умолчанию срабатывает метод самого Front-роутера, который находит страницу по URL и возвращает массив с ней и всеми ее предками
 - на основе пути находится инфоблок-лейаут для текущей страницы и выполняется его рендеринг - запускается контроллер \Floxim\Floxim\Controller\Layout, он получает инфоблоки, которые надо показать на странице, далее результат пропускается через шаблон-тему
 - тема содержит области (area, например "шапка", "сайдбар", "контент"), которым назначены инфоблоки, в процессе отрисовки лейаута области заполняются инфоблоками, каждый из которых тоже рендерится

6. Устройство инфоблока

Инфоблок хранит информацию о том, что на таких-то страницах сайта в таком-то месте нужно показать результат работы такого-то контроллера, отрисованный таким-то шаблоном. То есть это запись в БД, с такими полями (таблица fx_infoblock):

 - название блока (например "Главное меню")
 - сайт (Floxim - мультисайтовая система)
 - контроллер-экшн, который нужно дернуть для получения данных (например, контроллер floxim.nav.section, экшн list_infoblock - соответствует методу \Floxim\Nav\Section\Controller::doListInfoblock )
 - параметры экшна (задаются в настройках блока через UI, например сколько объектов показывать, как сортировать и т.д.)
 - scope - "область видимости" - правило, описывающее набор страниц, на которых отображается блок (например: Все страницы типа "Новость", вложенные в раздел "О компании")
 
У инфоблока есть "визуальная часть", вынесенная в таблицу fx_infoblock_visual - для того, чтобы один блок можно было показывать разными шаблонами в зависимости от текущей выбранной шкуры сайта. Там есть вот что:

 - "шаблон-обертка" (wrapper) - результат отрисовки блока можно "обернуть" в другой шаблон, для единообразного оформления блоков
 - параметры обертки (wrapper_visual, json-данные)
 - шаблон для рендеринга данных, пришедших из контроллера (template)
 - параметры шаблона (template_visual, json-данные, которые добавляются к результату работы контроллера перед рендерингом шаблона)
 - код области, где должен располагаться блок (area)
 - позиция блока (priority)
 
Таким образом, каждый блок рендерится в рамках своего микро-MVC, и этот процесс конфигурируется при помощи механизма инфоблоков.

7. Модель данных

В отличие от многих фреймворков, в модели Floxim явно выделяется два класса:
 - Finder - класс, отвечающий за выборки и непосредственно работу с БД, используется для построения запросов (queryBuilder)
 - Entity - класс, представляющий экземпляр модели
 
Все "системные" модели живут в папке /vendor/Floxim/Floxim/Component/Smth 
 
Например, для модели infoblock (т.е. табличка с инфоблоками) Finder - класс \Floxim\Floxim\Component\Infoblock\Finder, а Entity - \Floxim\Floxim\Component\Infoblock\Entity.

Получить все инфоблоки для сайта #18 можно вот так:

$finder = new \Floxim\Floxim\Component\Infoblock\Finder();
$blocks = $finder->where('site_id', 18)->all();

Чтобы не писать это все, есть метод-хелпер fx::data(). Можно написать и так:

$blocks = fx::data('infoblock')->where('site_id', 18)->all();

Каждый полученный блок - экземпляр \Floxim\Floxim\Component\Infoblock\Entity, который предоставляет доступ к свойствам через ArrayAccess и методы для сохранения/удаления. Можно сделать, например, вот это:

foreach ($blocks as $block) {
    $block['site_id'] = 19;
    $block->save();
}

8. Коллекции

Почти везде вместо массивов используются "коллекции" (экземпляры \Floxim\Floxim\System\Collection). Это обертка над массивом, нужная для двух вещей:

 -  Добавить вкусностей, типа такого:

$blocks = fx::data('infoblock')->all();

$blocks
	// найти все блоки, у которых action = 'list_infoblock'
	->find('action', 'list_infoblock')
    // сгруппировать по свойству controller (вернет коллекцию коллекций)
    ->group('controller')
    // для каждой группы применить коллбэк
    ->apply(
    	function($group, $key) {
    		echo 'Com '.$key.' has '.count($group).' ibs: '.join(", ", $group->getValues('id'))."<br />";
		}
	);

 -  Коллекции являются объектами, соответственно никогда не копируются при передаче.
 
9. Компоненты

Компонент - это тип данных (таблица в БД), соответствующие классы моделей, класс-контроллер и набор шаблонов. На данный момент следуюет отличать "пользовательские" компоненты (например "Блог") от системных моделей (например, тот же Infoblock).

Компоненты можно создавать через UI (вкдалка "Разработка - Компоненты"), через админку можно добавлять/изменять/удалять поля. При создании компонента генерируются нужные классы модели и контроллера, которые далее можно заполнить своими методами.

Компонент должен быть привязан к модулю, а модуль - к вендору. Ключевое слово компонента имеет вид "вендор.модуль.код", например "floxim.nav.section" (компонент "Раздел" модуля "Nav" вендора "Floxim"). Такая запись используется для получения данных, именования шаблонов и т.д. По умолчанию используется вендор "My", его можно переопределить, добавив в /config.php параметр 'dev.vendor' => 'yourname' (можно несколько через запятую).

Компоненты во Floxim наследуются, то есть дочерний компонент имеет все поля, которые есть у родителя. Реализовано это через общие записи ID в нескольких таблицах (например, есть "Новость" наследуется от "Страницы", каждой записи из таблицы "Новости" соответствует запись из таблицы "Страницы" с тем же идентификатором).  При этом классы моделей/контроллеров также повторяют цепочку наследования компонента.

Сейчас все компоненты должны наследоваться от компонента floxim.main.content - в нем определены системные поля: тип записи, кто и когда создал запись, к какому инфоблоку она относится, состояние публикации, поля для хранения иерархии (parent_id, level, materialized_path). 

Поля компонентов описываются в табличке fx_field. Данные, характерные для конкретного типа поля, заказываются в json в поле format. 

Есть планы по объединению "системных" и "пользовательских" компонентов в один механизм, примерно так:
 - сделать возможность заводить компоненты, не являющиеся наследниками floxim.main.content (то есть образующие собственное пространство ID) - для всяких служебно-словарных данных, которым не нужно положение в иерархии сайта
 - сделать, чтобы информация о полях "системных" компонентов также хранилась в fx_fields и была возможность добавлять кастомные поля к системным объектам.
 
10. Контроллеры и экшны

Экшн - метод контроллера с префиксом "do". Имя метода (как любых прочих методов) пишется в camelCase, но при нотации в шаблонах / кратких вызовах и т.д. может использоваться и under_score. Инициализировать и выполнить контроллер можно вот так (но не нужно, т.к. обычно такой вызов происходит глубоко внутри инфоблока):

$res = fx::controller(
            // контроллер компонента News из модуля Blog от вендора Floxim
            // метод doListFiltered
            'floxim.blog.news:list_filtered',
            // массив параметров, например "ограничиться 5-ю результатами"
            array('limit' => 5)
       )
       // выполнить и вернуть результат
       ->process();

В классе-контроллере компонента floxim.main.content объявляются методы-экшны, реализующие ряд стандартных задач. Это три "списочных" экшна и экшн для отрисовки отдельной страницы.

 - list_infoblock - выводит записи, привязанные к текущему инфоблоку. В инфоблок с таким контроллер-экшном можно добавлять данные.
 - list_filtered - выводит записи, отфильтрованные по набору условий (может быть не задан) - годится для всяких "Последние новости", "Свежие фото", а тажке для дублирования навигации
 - list_selected - выводит записи, выбранные вручную.
 - record - выводит запись, соответствующую текущей странице.
 
Влиять на поведение метода можно через систему событий (ну, кроме полного переопределения). В процессе выполнения базовый контроллер генерирует события:
 - запрос готов (можно пойамать и добавить к запросу дополнительные фильтры)
 - объекты готовые (можно обойти объекты и как-то их модифицировать, отфильтровать или дополнить)
 - результат готов (общее событие для всех экшнов).
 
Из компонента-наследника эти события можно обрабатывать так:

public function doListInfoblock() {
    $this->onQueryReady(function($e) {
        // получаем finder-запрос
        $e['query']
            // очищаем все сортировки
            ->order(null)
            // добавляем правильную сортировку
            ->order('cool_field', 'desc')
            // и лимит
            ->limit(5);
    });
    $this->onItemsReady(function($e) {
        // коллекция с найденными объектами
        $e['items']
            // найти и удалить объекты, для которых колбэк вернет true
            ->findRemove(function($i) {
                return $i->isNotVeryCool();
            })
            // пересортировать по id 
            ->sort('id');
    });
    return parent::doListInfoblock();
}
 
Все "списочные" экшны проходят через общий метод doList, соответственно, если надо поменять поведение всех таких экшнов, можно переопределить doList и навесить события в нем.

Еще есть экшны для отрисовки форм добавления/редактирования, но они пока не вполне production-ready :)

Результат работы контроллера собирается из данных, которые вернул метод-экшн и данных, добавленных через $this->assign('key', $data).

10. Шаблоны

11. События

12. Полезные инструменты

Для отладки можно использовать логгер - в любом месте кода пишем:
 fx::log($what, $you, $want);

И ищем результат во вкладке "Development - Logs". Можно вывести объекты прямо на экран методом fx::debug($a1, $a2);

Дебаггер делает print_r($data) и затем парсит результат, превращая в кликабельное дерево. Поэтому для больших сильно залинкованных структур данных оно может работать очень долго, сжирать всю память и т.д. Когда-нибудь мы допилим его, чтобы он возвращал json со специальными пометками вместо ссылок.

Еще есть консоль, где можно вбить кусок кода на PHP и посмотреть, чтоб получится. Искать - "Development - Console". Например, можно быстро найти и посмотреть все разделы сайта, скопипастив в консоль вот такой код:

<?php
$pages = fx::data('floxim.nav.section')
			// получить все разделы
			->all()
            // выдрать значения
            ->getValues( 
            	// полей url и name
            	array('url', 'name'), 
                // использовать id как ключ
                'id'
             );

fx::debug($pages);

Покажет примерно это: http://joxi.ru/BA0v0G6FbOvzmy

В шапке - тайминг и последний элемент трейса. Развернуть всю ветку можно через Ctrl+click.

Консоль хорошо подходит для всяких служебных операций и экспериментов.
